<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">



<title>
  
    归档: 2016
  
</title>

<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/archives/2016/index.html">
<meta property="og:site_name" content="Hexo">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">


  <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">



  <link rel="icon" href="/favicon.png">


<link rel="stylesheet" href="/perfect-scrollbar/css/perfect-scrollbar.min.css">
<link rel="stylesheet" href="/styles/main.css">






</head>
<body
  
    class="monochrome"
  
  >
  <div class="mobile-header">
  <button class="sidebar-toggle" type="button">
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
    <span class="icon-bar"></span>
  </button>
  <a class="title" href="/">Hexo</a>
</div>

  <div class="main-container">
    <div class="sidebar">
  <div class="header">
    <h1 class="title"><a href="/">Hexo</a></h1>
    
    <div class="info">
      <div class="content">
        
        
          <div class="author">John Doe</div>
        
      </div>
      
        <div class="avatar">
          
            <a href="/about"><img src="https://cn.gravatar.com/avatar/35fef74d731255cd569c2c2b0b9e87e4?s=200"></a>
          
        </div>
      
    </div>
  </div>
  <div class="body">
    
      
        <ul class="nav">
          
            
              <li class="category-list-container">
                <a href="javascript:;">分类</a>
                
              </li>
            
          
            
              <li class="tag-list-container">
                <a href="javascript:;">标签</a>
                
              </li>
            
          
            
              <li class="archive-list-container">
                <a href="javascript:;">归档</a>
                <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/">2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/">2016</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/">2015</a><span class="archive-list-count">1</span></li></ul>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="/" title="Homepage">Homepage</a>
              </li>
            
          
            
              <li>
                <a href="/archives" title="By Year">By Year</a>
              </li>
            
          
        </ul>
      
        <ul class="nav">
          
            
              <li>
                <a href="https://github.com/denjones/hexo-theme-chan" title="Chan" target="_blank" rel="external">Chan</a>
              </li>
            
          
            
              <li>
                <a href="https://github.com/denjones" title="Github" target="_blank" rel="external">Github</a>
              </li>
            
          
            
              <li>
                <a href="/atom.xml" title="RSS">RSS</a>
              </li>
            
          
        </ul>
      
    
  </div>
</div>

    <div class="main-content">
      
        <div style="max-width: 1000px">
      
          

  
  
    
      
      
      <section class="archives-wrap">
        <div class="archive-year-wrap">
          <h1><a href="/archives/2016" class="archive-year">2016</a></h1>
        </div>
        <div class="post-list">
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/05/23/详细图解作用域链与闭包/" >
  详细图解作用域链与闭包
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/05/23/详细图解作用域链与闭包/"><span class="article-date">
  2016-05-23
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <p>##闭包<br>攻克闭包难题</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib0pbau0nEFr1SeJiaeZALrdHficRG2gPURShKgibxDjbh5X4KUlvaYCSaMtic5eYyk3WuQhdzgGrlmV1A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>初学JavaScript的时候，我在学习闭包上，走了很多弯路。而这次重新回过头来对基础知识进行梳理，要讲清楚闭包，也是一个非常大的挑战。</p>
<p>闭包有多重要？如果你是初入前端的朋友，我没有办法直观的告诉你闭包在实际开发中的无处不在，但是我可以告诉你，前端面试，必问闭包。面试官们常常用对闭包的了解程度来判定面试者的基础水平，保守估计，10个前端面试者，至少5个都死在闭包上。</p>
<p>可是为什么，闭包如此重要，还是有那么多人没有搞清楚呢？是因为大家不愿意学习吗？还真不是，而是我们通过搜索找到的大部分讲解闭包的中文文章，都没有清晰明了的把闭包讲解清楚。要么浅尝辄止，要么高深莫测，要么干脆就直接乱说一通。包括我自己曾经也写过一篇关于闭包的总结，回头一看，不忍直视[捂脸]。</p>
<p>因此本文的目的就在于，能够清晰明了得把闭包说清楚，让读者老爷们看了之后，就把闭包给彻底学会了，而不是似懂非懂。</p>
<p>一、作用域与作用域链</p>
<p>在详细讲解作用域链之前，我默认你已经大概明白了JavaScript中的下面这些重要概念。这些概念将会非常有帮助。</p>
<p>基础数据类型与引用数据类型<br>内存空间<br>垃圾回收机制<br>执行上下文<br>变量对象与活动对象<br>如果你暂时还没有明白，可以去看本系列的前三篇文章，本文文末有目录链接。为了讲解闭包，我已经为大家做好了基础知识的铺垫。哈哈，真是好大一出戏。</p>
<p>作用域</p>
<p>在JavaScript中，我们可以将作用域定义为一套规则,这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。</p>
<p>这里的标识符，指的是变量名或者函数名</p>
<p>JavaScript中只有全局作用域与函数作用域(因为eval我们平时开发中几乎不会用到它，这里不讨论)。</p>
<p>作用域与执行上下文是完全不同的两个概念。我知道很多人会混淆他们，但是一定要仔细区分。</p>
<p>JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib0pbau0nEFr1SeJiaeZALrdHficRG2gPURShKgibxDjbh5X4KUlvaYCSaMtic5eYyk3WuQhdzgGrlmV1A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>作用域链</p>
<p>回顾一下上一篇文章我们分析的执行上下文的生命周期，如下图。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib0pbau0nEFr1SeJiaeZALrdHficRG2gPURShKgibxDjbh5X4KUlvaYCSaMtic5eYyk3WuQhdzgGrlmV1A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>执行上下文生命周期</p>
<p>我们发现，作用域链是在执行上下文的创建阶段生成的。这个就奇怪了。上面我们刚刚说作用域在编译阶段确定规则，可是为什么作用域链却在执行阶段确定呢？</p>
<p>之所有有这个疑问，是因为大家对作用域和作用域链有一个误解。我们上面说了，作用域是一套规则，那么作用域链是什么呢？是这套规则的具体实现。所以这就是作用域与作用域链的关系，相信大家都应该明白了吧。</p>
<p>我们知道函数在调用激活时，会开始创建对应的执行上下文，在执行上下文生成的过程中，变量对象，作用域链，以及this的值会分别被确定。之前一篇文章我们详细说明了变量对象，而这里，我们将详细说明作用域链。</p>
<p>作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。</p>
<p>为了帮助大家理解作用域链，我我们先结合一个例子，以及相应的图示来说明。</p>
<p>var a = 20;<br>function test() {<br>var b = a + 10;</p>
<p>function innerTest() {</p>
<pre><code>var c = 10;

return b + c;
</code></pre><p>}</p>
<p>return innerTest();<br>}<br>test();<br>在上面的例子中，全局，函数test，函数innerTest的执行上下文先后创建。我们设定他们的变量对象分别为VO(global)，VO(test), VO(innerTest)。而innerTest的作用域链，则同时包含了这三个变量对象，所以innerTest的执行上下文可如下表示。</p>
<p>innerTestEC = {<br>VO: {…},  // 变量对象</p>
<p>scopeChain: [VO(innerTest), VO(test), VO(global)], // 作用域链</p>
<p>this: {}<br>}<br>是的，你没有看错，我们可以直接用一个数组来表示作用域链，数组的第一项scopeChain[0]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。</p>
<p>很多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。以最前端为起点，最末端为终点的单方向通道我认为是更加贴切的形容。如图。</p>
<p>作用域链图示</p>
<p>注意，因为变量对象在执行上下文进入执行阶段时，就变成了活动对象，这一点在上一篇文章中已经讲过，因此图中使用了AO来表示。Active Object</p>
<p>是的，作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。</p>
<p>二、闭包</p>
<p>对于那些有一点 JavaScript 使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，突破闭包的瓶颈可以使你功力大增。</p>
<p>闭包与作用域链息息相关；<br>闭包是在函数执行过程中被确认。<br>先直截了当的抛出闭包的定义：当函数可以记住并访问所在的作用域(全局作用域除外)时，就产生了闭包，即使函数是在当前作用域之外执行。</p>
<p>简单来说，假设函数A在函数B的内部进行定义了，并且当函数A在执行时，访问了函数B内部的变量对象，那么B就是一个闭包。<br>非常抱歉之前对于闭包定义的描述有一些不准确，现在已经改过，希望收藏文章的同学再看到的时候能看到吧，对不起大家了。</p>
<p>在基础进阶（一）中，我总结了JavaScript的垃圾回收机制。JavaScript拥有自动的垃圾回收机制，关于垃圾回收机制，有一个重要的行为，那就是，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。</p>
<p>而我们知道，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。</p>
<p>先来一个简单的例子。</p>
<p>var fn = null;<br>function foo() {<br>var a = 2;</p>
<p>function innnerFoo() {</p>
<pre><code>console.log(a);
</code></pre><p>}</p>
<p>fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn<br>}<br>function bar() {<br>fn(); // 此处的保留的innerFoo的引用<br>}<br>foo();<br>bar(); // 2<br>在上面的例子中，foo()执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过fn = innerFoo，函数innerFoo的引用被保留了下来，复制给了全局变量fn。这个行为，导致了foo的变量对象，也被保留了下来。于是，函数fn在函数bar内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。</p>
<p>这样，我们就可以称foo为闭包。</p>
<p>下图展示了闭包fn的作用域链。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib0pbau0nEFr1SeJiaeZALrdHficRG2gPURShKgibxDjbh5X4KUlvaYCSaMtic5eYyk3WuQhdzgGrlmV1A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>闭包fn的作用域链</p>
<p>我们可以在chrome浏览器的开发者工具中查看这段代码运行时产生的函数调用栈与作用域链的生成情况。如下图。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_png/zPh0erYjkib0pbau0nEFr1SeJiaeZALrdHficRG2gPURShKgibxDjbh5X4KUlvaYCSaMtic5eYyk3WuQhdzgGrlmV1A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="img"></p>
<p>从图中可以看出，chrome浏览器认为闭包是foo，而不是通常我们认为的</p>
<p>innerFoo在上面的图中，红色箭头所指的正是闭包。其中Call Stack为当前的函数调用栈，Scope为当前正在被执行的函数的作用域链，Local为当前的局部变量。</p>
<p>所以，通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量。比如在上面的例子中，我们在函数bar的执行环境中访问到了函数foo的a变量。个人认为，从应用层面，这是闭包最重要的特性。利用这个特性，我们可以实现很多有意思的东西。</p>
<p>不过读者老爷们需要注意的是，虽然例子中的闭包被保存在了全局变量中，但是闭包的作用域链并不会发生任何改变。在闭包中，能访问到的变量，仍然是作用域链上能够查询到的变量。</p>
<p>对上面的例子稍作修改，如果我们在函数bar中声明一个变量c，并在闭包fn中试图访问该变量，运行结果会抛出错误。</p>
<p>var fn = null;<br>function foo() {<br>var a = 2;</p>
<p>function innnerFoo() {</p>
<pre><code>console.log(c); // 在这里，试图访问函数bar中的c变量，会抛出错误

console.log(a);
</code></pre><p>}</p>
<p>fn = innnerFoo; // 将 innnerFoo的引用，赋值给全局变量中的fn<br>}<br>function bar() {<br>var c = 100;</p>
<p>fn(); // 此处的保留的innerFoo的引用<br>}<br>foo();<br>bar();<br>闭包的应用场景</p>
<p>接下来，我们来总结下，闭包的常用场景。</p>
<p>延迟函数setTimeout<br>我们知道setTimeout的第一个参数是一个函数，第二个参数则是延迟的时间。在下面例子中，</p>
<p>function fn() {<br>console.log(‘this is test.’)<br>}<br>var timer = setTimeout(fn, 1000);<br>console.log(timer);<br>执行上面的代码，变量timer的值，会立即输出出来，表示setTimeout这个函数本身已经执行完毕了。但是一秒钟之后，fn才会被执行。这是为什么？</p>
<p>按道理来说，既然fn被作为参数传入了setTimeout中，那么fn将会被保存在setTimeout变量对象中，setTimeout执行完毕之后，它的变量对象也就不存在了。可是事实上并不是这样。至少在这一秒钟的事件里，它仍然是存在的。这正是因为闭包。</p>
<p>很显然，这是在函数的内部实现中，setTimeout通过特殊的方式，保留了fn的引用，让setTimeout的变量对象，并没有在其执行完毕后被垃圾收集器回收。因此setTimeout执行结束后一秒，我们任然能够执行fn函数。</p>
<p>柯里化<br>在函数式编程中，利用闭包能够实现很多炫酷的功能，柯里化算是其中一种。关于柯里化，我会在以后详解函数式编程的时候仔细总结。</p>
<p>模块<br>在我看来，模块是闭包最强大的一个应用场景。如果你是初学者，对于模块的了解可以暂时不用放在心上，因为理解模块需要更多的基础知识。但是如果你已经有了很多JavaScript的使用经验，在彻底了解了闭包之后，不妨借助本文介绍的作用域链与闭包的思路，重新理一理关于模块的知识。这对于我们理解各种各样的设计模式具有莫大的帮助。</p>
<p>(function () {<br>var a = 10;</p>
<p>var b = 20;</p>
<p>function add(num1, num2) {</p>
<pre><code>var num1 = !!num1 ? num1 : a;

var num2 = !!num2 ? num2 : b;



return num1 + num2;
</code></pre><p>}</p>
<p>window.add = add;<br>})();<br>add(10, 20);<br>在上面的例子中，我使用函数自执行的方式，创建了一个模块。方法add被作为一个闭包，对外暴露了一个公共方法。而变量a，b被作为私有变量。在面向对象的开发中，我们常常需要考虑是将变量作为私有变量，还是放在构造函数中的this中，因此理解闭包，以及原型链是一个非常重要的事情。模块十分重要，因此我会在以后的文章专门介绍，这里就暂时不多说啦。</p>
<p>此图中可以观看到当代码执行到add方法时的调用栈与作用域链，此刻的闭包为外层的自执行函数</p>
<p>为了验证自己有没有搞懂作用域链与闭包，这里留下一个经典的思考题，常常也会在面试中被问到。</p>
<p>利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4， 5</p>
<p>for (var i=1; i&lt;=5; i++) {<br>setTimeout( function timer() {</p>
<pre><code>console.log(i);
</code></pre><p>}, i*1000 );<br>}<br>关于作用域链的与闭包我就总结完了，虽然我自认为我是说得非常清晰了，但是我知道理解闭包并不是一件简单的事情，所以如果你有什么问题，可以在评论中问我。你也可以带着从别的地方没有看懂的例子在评论中留言。大家一起学习进步。</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/03/23/关于跨域/" >
  关于跨域
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/03/23/关于跨域/"><span class="article-date">
  2016-03-23
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <p>##关于跨域<br>前端跨域请求原理及实践 2017-02-17<br>一、 跨域请求的含义</p>
<p>浏览器的同源策略，出于防范跨站脚本的攻击，禁止客户端脚本（如 JavaScript）对不同域的服务进行跨站调用。</p>
<p>一般的，只要网站的 协议名protocol、 主机host、 端口号port 这三个中的任意一个不同，网站间的数据请求与传输便构成了跨域调用。这也是我们下面实践的理论基础。我们利用 NodeJs 创建了两个服务器，分别监听 3000、 3001 端口（下面简称 服务器3000 与 服务器3001 ），由于端口号不一样，这两个服务器以及服务器上页面通信构成了跨域请求。</p>
<p>在服务器3000 上有如下的页面：</p>
<p>img</p>
<p>服务器3000 上的请求页面中包含如下 JavaScript 代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">$(<span class="string">"#submit"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> data = &#123;</div><div class="line"></div><div class="line">        <span class="attr">name</span>: $(<span class="string">"#name"</span>).val(),</div><div class="line"></div><div class="line">        <span class="attr">id</span>: $(<span class="string">"#id"</span>).val()</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    $.ajax(&#123;</div><div class="line"></div><div class="line">        <span class="attr">type</span>: <span class="string">'POST'</span>,</div><div class="line"></div><div class="line">        <span class="attr">data</span>: data,</div><div class="line"></div><div class="line">        <span class="attr">url</span>: <span class="string">'http://localhost:3000/ajax/deal'</span>,</div><div class="line"></div><div class="line">        <span class="attr">dataType</span>: <span class="string">'json'</span>,</div><div class="line"></div><div class="line">        <span class="attr">cache</span>: <span class="literal">false</span>,</div><div class="line"></div><div class="line">        <span class="attr">timeout</span>: <span class="number">5000</span>,</div><div class="line"></div><div class="line">        <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="built_in">console</span>.log(data)</div><div class="line"></div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR, textStatus, errorThrown</span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'error '</span> + textStatus + <span class="string">' '</span> + errorThrown);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>服务器3000 对应的处理函数为<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">pp.post(‘/ajax/deal’, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"server accept: "</span>, req.body.name, req.body.id)</div><div class="line"></div><div class="line"><span class="keyword">var</span> data = &#123;</div><div class="line"></div><div class="line">    <span class="attr">name</span>: req.body.name + <span class="string">' - server 3000 process'</span>,</div><div class="line"></div><div class="line">    <span class="attr">id</span>: req.body.id + <span class="string">' - server 3000 process'</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">res.send(data)</div><div class="line"></div><div class="line">res.end()</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>请求页面返回结果：</p>
<p>img</p>
<p>此处数据处理成功。</p>
<p>由于数据请求一般都是由页面发送数据字段，服务器根据这些字段作相应的处理，如数据库查询，字符串操作等等。所以我们这里简单的处理数据（在数据后面加上字符串‘server 3000 process’），并且返回给浏览器，表示数据经过服务器端处理。</p>
<p>如果让 服务器3000 上的页面向 服务器 3001 发起请求会怎样呢？</p>
<p>将请求页面中的 ajax 请求路径改为：</p>
<p>$.ajax({<br>…</p>
<p>url: ‘<a href="http://localhost:3001/ajax/deal" target="_blank" rel="external">http://localhost:3001/ajax/deal</a>‘,</p>
<p>…<br>});<br>服务器3001 对应的处理函数与 服务器3000 类似：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">app.post(‘/ajax/deal’, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"server accept: "</span>, req.body.name, req.body.id)</div><div class="line"></div><div class="line"><span class="keyword">var</span> data = &#123;</div><div class="line"></div><div class="line">    <span class="attr">name</span>: req.body.name + <span class="string">' - server 3001 process'</span>,</div><div class="line"></div><div class="line">    <span class="attr">id</span>: req.body.id + <span class="string">' - server 3001 process'</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">res.send(data)</div><div class="line"></div><div class="line">res.end()</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>结果如下：</p>
<p>img</p>
<p>结果证明了我们上面所说的端口号不同，发生了跨域请求的调用。</p>
<p>需要注意的是，服务器 3001 控制台有输出：</p>
<p>server accept: chiaki 3001<br>这说明跨域请求并非是浏览器限制了发起跨站请求，而是请求可以正常发起，到达服务器端，但是服务器返回的结果会被浏览器拦截。</p>
<p>二、 利用 JSONP 实现跨域调用</p>
<p>说道跨域调用，可能大家首先想到的或者听说过的就是 JSONP 了。</p>
<p>2.1 什么是JSONP</p>
<p>JSONP (JSON with Padding or JSON-P) is a JSON extension used by web developers to overcome the cross-domain restrictions imposed by browsers’ same-origin policy that limits access to resources retrieved from origins other than the one the page was served by. In layman’s terms, one website cannot just simply access the data from another website.<br>It was developed because handling a browsers’ same origin policy can be difficult, so using JSONP abstracts the difficulties and makes it easier.<br>JSON stands for “JavaScript Object Notation”, a format by which object fields are represented as key-value pairs which is used to represent data.<br>JSONP 是 JSON 的一种使用模式，可以解决主流浏览器的跨域数据访问问题。其原理是根据 XmlHttpRequest 对象受到同源策略的影响，而</p>
<p>这样从服务器返回的代码就可以直接在这个 script 标签中运行了。下面我们自己实现一个 JSONP：</p>
<p>服务器 3000请求页面的 JavaScript 代码中，只有回调函数 jsonpCallback：</p>
<p>function jsonpCallback(data) {<br>console.log(“jsonpCallback: “+data.name)<br>}<br>服务器 3000请求页面还包含一个 script 标签：</p>
<p>服务器 3001上对应的处理函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">app.get(‘/jsonServerResponse’, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> cb = req.query.jsonp</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(cb)</div><div class="line"></div><div class="line"><span class="keyword">var</span> data = <span class="string">'var data = &#123;'</span> + <span class="string">'name: $("#name").val() + " - server 3001 jsonp process",'</span> + <span class="string">'id: $("#id").val() + " - server 3001 jsonp process"'</span> + <span class="string">'&#125;;'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> debug = <span class="string">'console.log(data);'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> callback = <span class="string">'$("#submit").click(function() &#123;'</span> + data + cb + <span class="string">'(data);'</span> + debug + <span class="string">'&#125;);'</span></div><div class="line"></div><div class="line">res.send(callback)</div><div class="line"></div><div class="line">res.end()</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>与上面一样，我们在所获取的参数后面加上 “ – server 3001 jsonp process” 代表服务器对数据的操作。从代码中我么可以看到，处理函数除了根据参数做相应的处理，更多的也是进行字符串的拼接。</p>
<p>最终的结果为：</p>
<p>img</p>
<p>2.4 JSONP 总结</p>
<p>至此，我们了解了 JSONP 的原理以及实现方式，它帮我们实现前端跨域请求，但是在实践的过程中，我们还是可以发现它的不足：</p>
<p>只能使用 GET 方法发起请求，这是由于 script 标签自身的限制决定的。</p>
<p>不能很好的发现错误，并进行处理。与 Ajax 对比，由于不是通过 XmlHttpRequest 进行传输，所以不能注册 success、 error 等事件监听函数。</p>
<p>三、 使用 CORS 实现跨域调用</p>
<p>3.1 什么是 CORS？</p>
<p>Cross-Origin Resource Sharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了 Web 服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，是 JSONP 模式的现代版。与 JSONP 不同，CORS 除了 GET 要求方法以外也支持其他的 HTTP 要求。用 CORS 可以让网页设计师用一般的 XMLHttpRequest，这种方式的错误处理比 JSONP 要来的好。另一方面，JSONP 可以在不支持 CORS 的老旧浏览器上运作。现代的浏览器都支持 CORS。</p>
<p>3.2 CORS 的实现</p>
<p>还是以 服务器 3000 上的请求页面向 服务器 3001 发送请求为例。</p>
<p>服务器 3000 上的请求页面 JavaScript 不变，如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">$(<span class="string">"#submit"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">var</span> data = &#123;</div><div class="line"></div><div class="line">        <span class="attr">name</span>: $(<span class="string">"#name"</span>).val(),</div><div class="line"></div><div class="line">        <span class="attr">id</span>: $(<span class="string">"#id"</span>).val()</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    $.ajax(&#123;</div><div class="line"></div><div class="line">        <span class="attr">type</span>: <span class="string">'POST'</span>,</div><div class="line"></div><div class="line">        <span class="attr">data</span>: data,</div><div class="line"></div><div class="line">        <span class="attr">url</span>: <span class="string">'http://localhost:3001/cors'</span>,</div><div class="line"></div><div class="line">        <span class="attr">dataType</span>: <span class="string">'json'</span>,</div><div class="line"></div><div class="line">        <span class="attr">cache</span>: <span class="literal">false</span>,</div><div class="line"></div><div class="line">        <span class="attr">timeout</span>: <span class="number">5000</span>,</div><div class="line"></div><div class="line">        <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="built_in">console</span>.log(data)</div><div class="line"></div><div class="line">        &#125;,</div><div class="line"></div><div class="line">        <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">jqXHR, textStatus, errorThrown</span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="built_in">console</span>.log(<span class="string">'error '</span> + textStatus + <span class="string">' '</span> + errorThrown);</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>服务器 3001上对应的处理函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">app.post(‘/cors’, <span class="function"><span class="keyword">function</span>(<span class="params">req, res</span>) </span>&#123;</div><div class="line">res.header(<span class="string">"Access-Control-Allow-Origin"</span>, <span class="string">"*"</span>);</div><div class="line"></div><div class="line">res.header(<span class="string">"Access-Control-Allow-Headers"</span>, <span class="string">"X-Requested-With"</span>);</div><div class="line"></div><div class="line">res.header(<span class="string">"Access-Control-Allow-Methods"</span>, <span class="string">"PUT,POST,GET,DELETE,OPTIONS"</span>);</div><div class="line"></div><div class="line">res.header(<span class="string">"X-Powered-By"</span>, <span class="string">' 3.2.1'</span>)</div><div class="line"></div><div class="line">res.header(<span class="string">"Content-Type"</span>, <span class="string">"application/json;charset=utf-8"</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> data = &#123;</div><div class="line"></div><div class="line">    <span class="attr">name</span>: req.body.name + <span class="string">' - server 3001 cors process'</span>,</div><div class="line"></div><div class="line">    <span class="attr">id</span>: req.body.id + <span class="string">' - server 3001 cors process'</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(data)</div><div class="line"></div><div class="line">res.send(data)</div><div class="line"></div><div class="line">res.end()</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>在服务器中对返回信息的请求头进行了设置。</p>
<p>最终的结果为：</p>
<p>img</p>
<p>3.3 CORS 中属性的分析<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Access-Control-Allow-Origin</div><div class="line"></div><div class="line">The origin parameter specifies a URI that may access the resource. The browser must enforce this. For requests without credentials, the server may specify “*” as a wildcard, thereby allowing any origin to access the resource.</div><div class="line"></div><div class="line">Access-Control-Allow-Methods</div><div class="line"></div><div class="line">Specifies the method or methods allowed when accessing the resource. This is used in response to a preflight request. The conditions under which a request is preflighted are discussed above.</div><div class="line"></div><div class="line">Access-Control-Allow-Headers</div><div class="line"></div><div class="line">Used in response to a preflight request to indicate which HTTP headers can be used when making the actual request.</div></pre></td></tr></table></figure></p>
<p>3.4 CORS 与 JSONP 的对比</p>
<p>CORS 除了 GET 方法外，也支持其它的 HTTP 请求方法如 POST、 PUT 等。<br>CORS 可以使用 XmlHttpRequest 进行传输，所以它的错误处理方式比 JSONP 好。<br>JSONP 可以在不支持 CORS 的老旧浏览器上运作。<br>四、 一些其它的跨域调用方式</p>
<p>4.1 window.name</p>
<p>window对象有个name属性，该属性有个特征：即在一个窗口 (window) 的生命周期内，窗口载入的所有的页面都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。</p>

        
      </div>
    </div>

  

  
  
    
  

    <div class="post-list-item article">
      <h3 class="article-header">
        <a href="/2016/01/13/this指向问题/" >
  this指向问题
</a>

      </h3>
      

      <div class="article-info">
        <a href="/2016/01/13/this指向问题/"><span class="article-date">
  2016-01-13
</span>
</a>
        

        

      </div>
      <div class="article-entry">
        
          <p>##关于this指向问题<br>与我们常见的很多语言不同，JavaScript 函数中的 this 指向并不是在函数定义的时候确定的，而是在调用的时候确定的。换句话说，函数的调用方式决定了 this 指向。</p>
<p>JavaScript 中，普通的函数调用方式有三种：直接调用、方法调用和 new 调用。除此之外，还有一些特殊的调用方式，比如通过bind() 将函数绑定到对象之后再进行调用、通过 call()、apply() 进行调用等。而 es6 引入了箭头函数之后，箭头函数调用时，其 this 指向又有所不同。下面就来分析这些情况下的 this 指向。</p>
<p>直接调用</p>
<p>直接调用，就是通过 函数名(…) 这种方式调用。这时候，函数内部的 this 指向全局对象，在浏览器中全局对象是 window，在 NodeJs 中全局对象是 global。</p>
<p>来看一个例子：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div></pre></td><td class="code"><pre><div class="line">// 简单兼容浏览器和 NodeJs 的全局对象</div><div class="line">const _global = typeof window === “undefined” ? global : window;</div><div class="line">function test() &#123;</div><div class="line">console.log(this === _global);    // true</div><div class="line">&#125;</div><div class="line">test(); // 直接调用</div><div class="line">这里需要注意的一点是，直接调用并不是指在全局作用域下进行调用，在任何作用域下，直接通过 函数名(…) 来对函数进行调用的方式，都称为直接调用。比如下面这个例子也是直接调用</div><div class="line"></div><div class="line">(function(_global) &#123;</div><div class="line">// 通过 IIFE 限定作用域</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">function test() &#123;</div><div class="line"></div><div class="line">    console.log(this === _global);  // true</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">test();     // 非全局作用域下的直接调用</div><div class="line">&#125;)(typeof window === “undefined” ? global : window);</div><div class="line">bind() 对直接调用的影响</div><div class="line"></div><div class="line">还有一点需要注意的是 bind() 的影响。Function.prototype.bind() 的作用是将当前函数与指定的对象绑定，并返回一个新函数，这个新函数无论以什么样的方式调用，其 this 始终指向绑定的对象。还是来看例子：</div><div class="line"></div><div class="line">const obj = &#123;&#125;;</div><div class="line">function test() &#123;</div><div class="line">console.log(this === obj);</div><div class="line">&#125;</div><div class="line">const testObj = test.bind(obj);</div><div class="line">test(); // false</div><div class="line">testObj(); // true</div><div class="line">那么 bind() 干了啥？不妨模拟一个 bind() 来了解它是如何做到对 this 产生影响的。</div><div class="line"></div><div class="line">const obj = &#123;&#125;;</div><div class="line">function test() &#123;</div><div class="line">console.log(this === obj);</div><div class="line">&#125;</div><div class="line">// 自定义的函数，模拟 bind() 对 this 的影响</div><div class="line">function myBind(func, target) &#123;</div><div class="line">return function() &#123;</div><div class="line"></div><div class="line">    return func.apply(target, arguments);</div><div class="line"></div><div class="line">&#125;;</div><div class="line">&#125;</div><div class="line">const testObj = myBind(test, obj);</div><div class="line">test(); // false</div><div class="line">testObj(); // true</div><div class="line">从上面的示例可以看到，首先，通过闭包，保持了 target，即绑定的对象；然后在调用函数的时候，对原函数使用了 apply 方法来指定函数的 this。当然原生的 bind() 实现可能会不同，而且更高效。但这个示例说明了 bind() 的可行性。</div><div class="line"></div><div class="line">call 和 apply 对 this 的影响</div><div class="line"></div><div class="line">上面的示例中用到了 Function.prototype.apply()，与之类似的还有 Function.prototype.call()。这两方法的用法请大家自己通过链接去看文档。不过，它们的第一个参数都是指定函数运行时其中的 this 指向。</div><div class="line"></div><div class="line">不过使用 apply 和 call 的时候仍然需要注意，如果目录函数本身是一个绑定了 this 对象的函数，那 apply 和 call 不会像预期那样执行，比如</div><div class="line"></div><div class="line">const obj = &#123;&#125;;</div><div class="line">function test() &#123;</div><div class="line">console.log(this === obj);</div><div class="line">&#125;</div><div class="line">// 绑定到一个新对象，而不是 obj</div><div class="line">const testObj = test.bind(&#123;&#125;);</div><div class="line">test.apply(obj); // true</div><div class="line">// 期望 this 是 obj，即输出 true</div><div class="line">// 但是因为 testObj 绑定了不是 obj 的对象，所以会输出 false</div><div class="line">testObj.apply(obj); // false</div><div class="line">由此可见，bind() 对函数的影响是深远的，慎用！</div><div class="line"></div><div class="line">方法调用</div><div class="line"></div><div class="line">方法调用是指通过对象来调用其方法函数，它是 对象.方法函数(…) 这样的调用形式。这种情况下，函数中的 this 指向调用该方法的对象。但是，同样需要注意 bind() 的影响。</div><div class="line"></div><div class="line">const obj = &#123;</div><div class="line">// 第一种方式，定义对象的时候定义其方法</div><div class="line"></div><div class="line">test() &#123;</div><div class="line"></div><div class="line">    console.log(this === obj);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">// 第二种方式，对象定义好之后为其附加一个方法(函数表达式)</div><div class="line">obj.test2 = function() &#123;</div><div class="line">console.log(this === obj);</div><div class="line">&#125;;</div><div class="line">// 第三种方式和第二种方式原理相同</div><div class="line">// 是对象定义好之后为其附加一个方法(函数定义)</div><div class="line">function t() &#123;</div><div class="line">console.log(this === obj);</div><div class="line">&#125;</div><div class="line">obj.test3 = t;</div><div class="line">// 这也是为对象附加一个方法函数</div><div class="line">// 但是这个函数绑定了一个不是 obj 的其它对象</div><div class="line">obj.test4 = (function() &#123;</div><div class="line">console.log(this === obj);</div><div class="line">&#125;).bind(&#123;&#125;);</div><div class="line">obj.test(); // true</div><div class="line">obj.test2(); // true</div><div class="line">obj.test3(); // true</div><div class="line">// 受 bind() 影响，test4 中的 this 指向不是 obj</div><div class="line">obj.test4(); // false</div><div class="line">这里需要注意的是，后三种方式都是预定定义函数，再将其附加给 obj 对象作为其方法。再次强调，函数内部的 this 指向与定义无关，受调用方式的影响。</div><div class="line"></div><div class="line">方法中 this 指向全局对象的情况</div><div class="line"></div><div class="line">注意这里说的是方法中而不是方法调用中。方法中的 this 指向全局对象，如果不是因为 bind()，那就一定是因为不是用的方法调用方式，比如</div><div class="line"></div><div class="line">const obj = &#123;</div><div class="line">test() &#123;</div><div class="line"></div><div class="line">    console.log(this === obj);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">const t = obj.test;</div><div class="line">t(); // false</div><div class="line">t 就是 obj 的 test 方法，但是 t() 调用时，其中的 this 指向了全局。</div><div class="line"></div><div class="line">之所以要特别提出这种情况，主要是因为常常将一个对象方法作为回调传递给某个函数之后，却发现运行结果与预期不符——因为忽略了调用方式对 this 的影响。比如下面的例子是在页面中对某些事情进行封装之后特别容易遇到的问题：</div><div class="line"></div><div class="line">class Handlers &#123;</div><div class="line">// 这里 $button 假设是一个指向某个按钮的 jQuery 对象</div><div class="line"></div><div class="line">constructor(data, $button) &#123;</div><div class="line"></div><div class="line">    this.data = data;</div><div class="line"></div><div class="line">    $button.on("click", this.onButtonClick);</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">onButtonClick(e) &#123;</div><div class="line"></div><div class="line">    console.log(this.data);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">const handlers = new Handlers(“string data”, $(“#someButton”));</div><div class="line">// 对 #someButton 进行点击操作之后</div><div class="line">// 输出 undefined</div><div class="line">// 但预期是输出 string data</div><div class="line">很显然 this.onButtonClick 作为一个参数传入 on() 之后，事件触发时，是对这个函数进行的直接调用，而不是方法调用，所以其中的 this 会指向全局对象。要解决这个问题有很多种方法</div><div class="line"></div><div class="line">// 这是在 es5 中的解决办法之一</div><div class="line">var _this = this;</div><div class="line">$button.on(“click”, function() &#123;</div><div class="line">_this.onButtonClick();</div><div class="line">&#125;);</div><div class="line">// 也可以通过 bind() 来解决</div><div class="line">$button.on(“click”, this.onButtonClick.bind(this));</div><div class="line">// es6 中可以通过箭头函数来处理，在 jQuery 中慎用</div><div class="line">$button.on(“click”, e =&gt; this.onButtonClick(e));</div><div class="line">不过请注意，将箭头函数用作 jQuery 的回调时造成要小心函数内对 this 的使用。jQuery 大多数回调函数(非箭头函数)中的 this 都是表示调用目标，所以可以写 $(this).text() 这样的语句，但 jQuery 无法改变箭头函数的 this 指向，同样的语句语义完全不同。</div><div class="line"></div><div class="line">new 调用</div><div class="line"></div><div class="line">在 es6 之前，每一个函数都可以当作是构造函数，通过 new 调用来产生新的对象(函数内无特定返回值的情况下)。而 es6 改变了这种状态，虽然 class 定义的类用 typeof 运算符得到的仍然是 “function”，但它不能像普通函数一样直接调用；同时，class 中定义的方法函数，也不能当作构造函数用 new 来调用。</div><div class="line"></div><div class="line">而在 es5 中，用 new 调用一个构造函数，会创建一个新对象，而其中的 this 就指向这个新对象。这没有什么悬念，因为 new 本身就是设计来创建新对象的。</div><div class="line"></div><div class="line">var data = “Hi”; // 全局变量</div><div class="line">function AClass(data) &#123;</div><div class="line">this.data = data;</div><div class="line">&#125;</div><div class="line">var a = new AClass(“Hello World”);</div><div class="line">console.log(a.data); // Hello World</div><div class="line">console.log(data); // Hi</div><div class="line">var b = new AClass(“Hello World”);</div><div class="line">console.log(a === b); // false</div><div class="line">箭头函数中的 this</div><div class="line"></div><div class="line">先来看看 MDN 上对箭头函数的说明</div><div class="line"></div><div class="line">An arrow function expression has a shorter syntax than a function expression and does not bind its own this, arguments,super, or new.target. Arrow functions are always anonymous. These function expressions are best suited for non-method functions, and they cannot be used as constructors.</div><div class="line">这里已经清楚了说明了，箭头函数没有自己的 this 绑定。箭头函数中使用的 this，其实是直接包含它的那个函数或函数表达式中的 this。比如</div><div class="line"></div><div class="line">const obj = &#123;</div><div class="line">test() &#123;</div><div class="line"></div><div class="line">    const arrow = () =&gt; &#123;</div><div class="line"></div><div class="line">        // 这里的 this 是 test() 中的 this，</div><div class="line"></div><div class="line">        // 由 test() 的调用方式决定</div><div class="line"></div><div class="line">        console.log(this === obj);</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    arrow();</div><div class="line"></div><div class="line">&#125;,</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">getArrow() &#123;</div><div class="line"></div><div class="line">    return () =&gt; &#123;</div><div class="line"></div><div class="line">        // 这里的 this 是 getArrow() 中的 this，</div><div class="line"></div><div class="line">        // 由 getArrow() 的调用方式决定</div><div class="line"></div><div class="line">        console.log(this === obj);</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">obj.test(); // true</div><div class="line">const arrow = obj.getArrow();</div><div class="line">arrow(); // true</div><div class="line">示例中的两个 this 都是由箭头函数的直接外层函数(方法)决定的，而方法函数中的 this 是由其调用方式决定的。上例的调用方式都是方法调用，所以 this 都指向方法调用的对象，即 obj。</div><div class="line"></div><div class="line">箭头函数让大家在使用闭包的时候不需要太纠结 this，不需要通过像 _this 这样的局部变量来临时引用 this 给闭包函数使用。来看一段 Babel 对箭头函数的转译可能能加深理解：</div><div class="line"></div><div class="line">// ES6</div><div class="line">const obj = &#123;</div><div class="line">getArrow() &#123;</div><div class="line"></div><div class="line">    return () =&gt; &#123;</div><div class="line"></div><div class="line">        console.log(this === obj);</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">// ES5，由 Babel 转译</div><div class="line">var obj = &#123;</div><div class="line">getArrow: function getArrow() &#123;</div><div class="line"></div><div class="line">    var _this = this;</div><div class="line"></div><div class="line">    return function () &#123;</div><div class="line"></div><div class="line">        console.log(_this === obj);</div><div class="line"></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;;</div><div class="line">另外需要注意的是，箭头函数不能用 new 调用，不能 bind() 到某个对象(虽然 bind() 方法调用没问题，但是不会产生预期效果)。不管在什么情况下使用箭头函数，它本身是没有绑定 this 的，它用的是直接外层函数(即包含它的最近的一层函数或函数表达式)绑定的 this。</div></pre></td></tr></table></figure></p>

        
      </div>
    </div>

  






          <div class="main-footer">
  
    © 2017 Hexo - Powered by <a href="http://hexo.io" target="_blank">Hexo</a> - Theme <a href="https://github.com/denjones/hexo-theme-chan" target="_blank">Chan</a>
  
</div>

      
        </div>
      
    </div>
  </div>
  <script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>

  <link rel="stylesheet" href="/PhotoSwipe/photoswipe.css">
  <link rel="stylesheet" href="/PhotoSwipe/default-skin/default-skin.css">

  <!-- Root element of PhotoSwipe. Must have class pswp. -->
  <div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe.
             It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

      <!-- Container that holds slides.
                PhotoSwipe keeps only 3 of them in the DOM to save memory.
                Don't modify these 3 pswp__item elements, data is added later on. -->
      <div class="pswp__container">
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
        <div class="pswp__item"></div>
      </div>

      <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
      <div class="pswp__ui pswp__ui--hidden">

        <div class="pswp__top-bar">

          <!--  Controls are self-explanatory. Order can be changed. -->

          <div class="pswp__counter"></div>

          <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

          <button class="pswp__button pswp__button--share" title="Share"></button>

          <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

          <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

          <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
          <!-- element will get class pswp__preloader--active when preloader is running -->
          <div class="pswp__preloader">
            <div class="pswp__preloader__icn">
              <div class="pswp__preloader__cut">
                <div class="pswp__preloader__donut"></div>
              </div>
            </div>
          </div>
        </div>

        <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
          <div class="pswp__share-tooltip"></div>
        </div>

        <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>

        <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button>

        <div class="pswp__caption">
          <div class="pswp__caption__center"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="/PhotoSwipe/photoswipe.js"></script>
  <script src="/PhotoSwipe/photoswipe-ui-default.js"></script>


<script src="/perfect-scrollbar/js/min/perfect-scrollbar.min.js"></script>
<script src="/scripts/main.js"></script>

</body>
</html>
